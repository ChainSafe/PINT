initSidebarItems({"constant":[["MAX_SLOT_CAPACITY","We keep at least this number of slots in database."],["PRUNING_BOUND","We prune slots when they reach this number."]],"enum":[["CheckedHeader","A header which has been checked"],["Error",""],["SlotLenienceType","The strategy used to calculate the slot lenience used to increase the block proposal time when slots have been skipped with no blocks authored."]],"fn":[["check_equivocation","Checks if the header is an equivocation and returns the proof in that case."],["proposing_remaining_duration","Calculate the remaining duration for block proposal taking into account whether any slots have been skipped and applying the given lenience strategy. If `max_block_proposal_slot_portion` is not none this method guarantees that the returned duration must be lower or equal to `slot_info.duration * max_block_proposal_slot_portion`."],["slot_lenience_exponential","Calculate a slot duration lenience based on the number of missed slots from current to parent. If the number of skipped slots is greated than 0 this method will apply an exponential backoff of at most `2^7 * slot_duration`, if no slots were skipped this method will return `None.`"],["slot_lenience_linear","Calculate a slot duration lenience based on the number of missed slots from current to parent. If the number of skipped slots is greated than 0 this method will apply a linear backoff of at most `20 * slot_duration`, if no slots were skipped this method will return `None.`"],["start_slot_worker","Start a new slot worker."]],"struct":[["BackoffAuthoringOnFinalizedHeadLagging","A simple default strategy for how to decide backing off authoring blocks if the number of unfinalized blocks grows too large."],["SlotDuration","A slot duration. Create with `get_or_compute`."],["SlotInfo","Information about a slot."],["SlotProportion","A unit type wrapper to express the proportion of a slot."],["SlotResult","The result of [`SlotWorker::on_slot`]."]],"trait":[["BackoffAuthoringBlocksStrategy","Trait for providing the strategy for when to backoff block authoring."],["InherentDataProviderExt","Slot specific extension that the inherent data provider needs to implement."],["SimpleSlotWorker","A skeleton implementation for `SlotWorker` which tries to claim a slot at its beginning and tries to produce a block if successfully claimed, timing out if block production takes too long."],["SlotWorker","A worker that should be invoked at every new slot."]],"type":[["StorageChanges","The changes that need to applied to the storage to create the state for a block."]]});