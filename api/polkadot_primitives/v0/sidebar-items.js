initSidebarItems({"constant":[["COLLATOR_KEY_TYPE_ID","The key type ID for a collator key."],["LOWEST_USER_ID","The ID of the first user (non-system) parachain."],["NEW_HEADS_IDENTIFIER","An identifier for inherent data that provides new minimally-attested parachain heads."],["PARACHAIN_INFO","An `Info` value for a standard leased parachain."],["PARACHAIN_KEY_TYPE_ID","The key type ID for a parachain validator key."]],"enum":[["Chain","Identifier for a chain, either one of a number of parachains or the relay chain."],["CompactStatement","Statements that can be made about parachain candidates. These are the actual values that are signed."],["Retriable","Retriability for a given active para."],["Scheduling","Description of how often/when this parachain is scheduled for progression."],["ValidityAttestation","An either implicit or explicit attestation to the validity of a parachain candidate."],["ValidityError","Custom validity errors used in Polkadot while validating transactions."]],"fn":[["collator_signature_payload","Get a collator signature payload on a relay-parent, block-data combo."]],"mod":[["fisherman","App-specific crypto used for reporting equivocation/misbehavior in BABE, GRANDPA and Parachains, described in the white paper as the fisherman role. Any rewards for misbehavior reporting will be paid out to this account."],["id","Runtime ID module."],["v1","`V1` primitives."]],"struct":[["AbridgedCandidateReceipt","An abridged candidate-receipt."],["AttestedCandidate","An attested candidate. This is submitted to the relay chain by a block author."],["AvailableData","The data that is kept available about a particular parachain block."],["BlakeTwo256","Blake2-256 Hash implementation."],["BlakeTwo256","Blake2-256 Hash implementation."],["BlockData","Parachain block data."],["CandidateCommitments","Commitments made in a `CandidateReceipt`. Many of these are outputs of validation."],["CandidateDescriptor","A unique descriptor of the candidate receipt, in a lightweight format."],["CandidateHash","Unit type wrapper around [`Hash`] that represents a candidate hash."],["CandidateReceipt","All data pertaining to the execution of a parachain candidate."],["Collation","A full collation."],["CollationInfo","A collation sent by a collator."],["CommitedCandidateReceipt","A candidate-receipt with commitments directly included."],["Compact","Compact-encoded variant of T. This is more space-efficient but less compute-efficient."],["DutyRoster","The duty roster specifying what jobs each validator must do."],["FeeSchedule","A fee schedule for messages. This is a linear function in the number of bytes of a message."],["GlobalValidationData","Extra data that is needed along with the other fields in a `CandidateReceipt` to fully validate the candidate."],["HeadData","Parachain head data included in the chain."],["Id","Unique identifier of a parachain."],["InboundDownwardMessage","A wrapped version of `DownwardMessage`. The difference is that it has attached the block number when the message was sent."],["InboundHrmpMessage","An HRMP message seen from the perspective of a recipient."],["Info","Information regarding a deployed parachain/thread."],["LocalValidationData","Extra data that is needed along with the other fields in a `CandidateReceipt` to fully validate the candidate. These fields are parachain-specific."],["OmittedValidationData","All the data which is omitted in an `AbridgedCandidateReceipt`, but that is necessary for validation of the parachain candidate."],["OutboundHrmpMessage","An HRMP message seen from the perspective of a sender."],["PoVBlock","A Proof-of-Validation block."],["SigningContext","A type returned by runtime with current session index and a parent hash."],["UncheckedExtrinsic","Simple blob to hold an extrinsic without committing to its format and ensure it is serialized correctly."],["ValidationCode","Parachain validation code."],["ValidatorIndex","Index of the validator is used as a lightweight replacement of the `ValidatorId` when appropriate."]],"trait":[["ActiveParas","Type determining the active set of parachains in current block."],["HashT","Abstraction around hashing"],["HashT","Abstraction around hashing"],["IdentifyAccount","Some type that is able to be collapsed into an account ID. It is not possible to recreate the original value from the account ID."],["ParachainHost","The API for querying the state of parachains on-chain."],["SwapAux","Auxiliary for when there’s an attempt to swap two parachains/parathreads."],["Verify","Means of signature verification."]],"type":[["AccountId","Alias to the opaque account ID type for this chain, actually a `AccountId32`. This is always 32 bytes."],["AccountIndex","The type for looking up accounts. We don’t expect more than 4 billion of them."],["AccountPublic","Alias to the public key used for this chain, actually a `MultiSigner`. Like the signature, this also isn’t a fixed size when encoded, as different cryptos have different size public keys."],["Balance","The balance of an account. 128-bits (or 38 significant decimal figures) will allow for 10 m currency (`10^7`) at a resolution to all for one second’s worth of an annualised 50% reward be paid to a unit holder (`10^11` unit denomination), or `10^18` total atomic units, to grow at 50%/year for 51 years (`10^9` multiplier) for an eventual total of `10^27` units (27 significant decimal figures). We round denomination to `10^12` (12 SDF), and leave the other redundancy at the upper end so that 32 bits may be multiplied with a balance in 128 bits without worrying about overflow."],["Block","Block type."],["BlockId","Block ID."],["BlockNumber","The block number type used by Polkadot. 32-bits will allow for 136 years of blocks assuming 1 block per second."],["ChainId","Identifier for a chain. 32-bit should be plenty."],["CollatorId","Identity that collators use."],["CollatorPair","A Parachain collator keypair."],["CollatorSignature","Signature on candidate’s block data by a collator."],["DownwardMessage","A message sent from the relay-chain down to a parachain."],["Hash","A hash of some data used by the relay chain."],["Header","Header type."],["Moment","An instant or duration in time."],["Nonce","Index of a transaction in the relay chain. 32-bit should be plenty."],["Remark","The information that goes alongside a `transfer_into_parachain` operation. Entirely opaque, it will generally be used for identifying the reason for the transfer. Typically it will hold the destination account to which the transfer should be credited. If still more information is needed, then this should be a hash with the pre-image presented via an off-chain mechanism on the parachain."],["Signature","Alias to type for a signature for a transaction on the relay chain. This allows one of several kinds of underlying crypto to be used, so isn’t a fixed size when encoded."],["UpwardMessage","A message from a parachain to its Relay Chain."],["ValidatorId","Identity that parachain validators use when signing validation messages."],["ValidatorPair","A Parachain validator keypair."],["ValidatorSignature","Signature with which parachain validators sign blocks."]]});