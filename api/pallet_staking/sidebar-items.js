initSidebarItems({"constant":[["MAX_UNLOCKING_CHUNKS",""]],"enum":[["Call","Contains one variant per dispatchable that can be called by an extrinsic."],["Error","Custom dispatch errors of this pallet."],["Event","The event emitted by this pallet."],["Forcing","Mode of era-forcing."],["RewardDestination","A destination account for payment."],["StakerStatus","Indicates the initial status of the staker."]],"macro":[["log",""]],"mod":[["benchmarking","Staking pallet benchmarking."],["inflation","This module expose one function `P_NPoS` (Payout NPoS) or `compute_total_payout` which returns the total payout for the era given the era duration and the staking rate in NPoS. The staking rate in NPoS is the total amount of tokens staked by nominators and validators, divided by the total token supply."],["migrations","Storage migrations for the Staking pallet."],["pallet","The module that hosts all the FRAME types needed to add this pallet to a runtime."],["slashing","A slashing implementation for NPoS systems."],["testing_utils","Testing utils for staking. Provides some common functions to setup staking state, such as bonding validators, nominators, and generating different types of solutions."],["weights","Autogenerated weights for pallet_staking"]],"struct":[["ActiveEraInfo","Information regarding the active era (era in used in session)."],["ConvertCurve","Adaptor to turn a `PiecewiseLinear` curve definition into an `EraPayout` impl, used for backwards compatibility."],["EraRewardPoints","Reward points of an era. Used to split era total payout between validators."],["Exposure","A snapshot of the stake backing a single validator in the system."],["ExposureOf","A typed conversion from stash account ID to the active exposure of nominators on that account."],["FilterHistoricalOffences","Filter historical offences out and only allow those from the bonding period."],["GenesisConfig","Can be used to configure the genesis state of this pallet."],["IndividualExposure","The amount of exposure (to slashing) than an individual nominator has."],["Nominations","A record of the nominations made by a specific account."],["Pallet","The pallet implementing the on-chain logic."],["StakingLedger","The ledger of a (bonded) stash."],["StashOf","A `Convert` implementation that finds the stash of the given controller account, if any."],["UnappliedSlash","A pending slash record. The value of the slash has been computed but not applied yet, rather deferred for several eras."],["UnlockChunk","Just a Balance/BlockNumber tuple to encode when a chunk of funds will be unlocked."],["UseNominatorsMap","A simple voter list implementation that does not require any additional pallets. Note, this does not provided nominators in sorted ordered. If you desire nominators in a sorted order take a look at [`pallet-bags-list]."],["ValidatorPrefs","Preference of what happens regarding validation."],["_GeneratedPrefixForStorageActiveEra",""],["_GeneratedPrefixForStorageBonded",""],["_GeneratedPrefixForStorageCanceledSlashPayout",""],["_GeneratedPrefixForStorageCounterForNominators",""],["_GeneratedPrefixForStorageCounterForValidators",""],["_GeneratedPrefixForStorageCurrentEra",""],["_GeneratedPrefixForStorageCurrentPlannedSession",""],["_GeneratedPrefixForStorageErasRewardPoints",""],["_GeneratedPrefixForStorageErasStakers",""],["_GeneratedPrefixForStorageErasStakersClipped",""],["_GeneratedPrefixForStorageErasStartSessionIndex",""],["_GeneratedPrefixForStorageErasTotalStake",""],["_GeneratedPrefixForStorageErasValidatorPrefs",""],["_GeneratedPrefixForStorageErasValidatorReward",""],["_GeneratedPrefixForStorageForceEra",""],["_GeneratedPrefixForStorageInvulnerables",""],["_GeneratedPrefixForStorageLedger",""],["_GeneratedPrefixForStorageMaxNominatorsCount",""],["_GeneratedPrefixForStorageMaxValidatorsCount",""],["_GeneratedPrefixForStorageMinNominatorBond",""],["_GeneratedPrefixForStorageMinValidatorBond",""],["_GeneratedPrefixForStorageMinimumValidatorCount",""],["_GeneratedPrefixForStorageNominators",""],["_GeneratedPrefixForStorageOffendingValidators",""],["_GeneratedPrefixForStoragePayee",""],["_GeneratedPrefixForStorageSlashRewardFraction",""],["_GeneratedPrefixForStorageUnappliedSlashes",""],["_GeneratedPrefixForStorageValidatorCount",""],["_GeneratedPrefixForStorageValidators",""]],"trait":[["Config","Configuration trait of this pallet."],["EraPayout","Handler for determining how much of a balance should be paid out on the current era."],["SessionInterface","Means for interacting with a specialized version of the `session` trait."]],"type":[["ActiveEra","The active era information, it holds index and start."],["BalanceOf","The balance type of this pallet."],["Bonded","Map from all locked “stash” accounts to the controller account."],["CanceledSlashPayout","The amount of currency given to reporters of a slash event which was canceled by extraordinary circumstances (e.g. governance)."],["CounterForNominators","A tracker to keep count of the number of items in the `Nominators` map."],["CounterForValidators","A tracker to keep count of the number of items in the `Validators` map."],["CurrentEra","The current era index."],["CurrentPlannedSession","The last planned session scheduled by the session pallet."],["EraIndex","Counter for the number of eras that have passed."],["ErasRewardPoints","Rewards for the last `HISTORY_DEPTH` eras. If reward hasn’t been set or has been removed then 0 reward is returned."],["ErasStakers","Exposure of validator at era."],["ErasStakersClipped","Clipped Exposure of validator at era."],["ErasStartSessionIndex","The session index at which the era start for the last `HISTORY_DEPTH` eras."],["ErasTotalStake","The total amount staked for the last `HISTORY_DEPTH` eras. If total hasn’t been set or has been removed then 0 stake is returned."],["ErasValidatorPrefs","Similar to `ErasStakers`, this holds the preferences of validators."],["ErasValidatorReward","The total validator era payout for the last `HISTORY_DEPTH` eras."],["ForceEra","Mode of era forcing."],["Invulnerables","Any validators that may never be slashed or forcibly kicked. It’s a Vec since they’re easy to initialize and the performance hit is minimal (we expect no more than four invulnerables) and restricted to testnets."],["Ledger","Map from all (unlocked) “controller” accounts to the info regarding the staking."],["MaxNominatorsCount","The maximum nominator count before we stop allowing new validators to join."],["MaxValidatorsCount","The maximum validator count before we stop allowing new validators to join."],["MinNominatorBond","The minimum active bond to become and maintain the role of a nominator."],["MinValidatorBond","The minimum active bond to become and maintain the role of a validator."],["MinimumValidatorCount","Minimum number of staking participants before emergency conditions are imposed."],["Module","Type alias to `Pallet`, to be used by `construct_runtime`."],["Nominators","The map from nominator stash key to the set of stash keys of all validators to nominate."],["OffendingValidators","Indices of validators that have offended in the active era and whether they are currently disabled."],["Payee","Where the reward payment should be made. Keyed by stash."],["RewardPoint","Counter for the number of “reward” points earned by a given validator."],["SlashRewardFraction","The percentage of the slash that is distributed to reporters."],["UnappliedSlashes","All unapplied slashes that are queued for later."],["ValidatorCount","The ideal number of staking participants."],["Validators","The map from (wannabe) validator stash key to the preferences of that validator."]]});