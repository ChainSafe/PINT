<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Multistream-select Protocol Negotiation"><meta name="keywords" content="rust, rustlang, rust-lang, multistream_select"><title>multistream_select - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../multistream_select/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate multistream_select</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.10.4</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all multistream_select's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="multistream_select" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">multistream_select</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/multistream_select/lib.rs.html#21-148" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="multistream-select-protocol-negotiation" class="section-header"><a href="#multistream-select-protocol-negotiation">Multistream-select Protocol Negotiation</a></h2>
<p>This crate implements the <code>multistream-select</code> protocol, which is the protocol
used by libp2p to negotiate which application-layer protocol to use with the
remote on a connection or substream.</p>
<blockquote>
<p><strong>Note</strong>: This crate is used primarily by core components of <em>libp2p</em> and it
is usually not used directly on its own.</p>
</blockquote>
<h3 id="roles" class="section-header"><a href="#roles">Roles</a></h3>
<p>Two peers using the multistream-select negotiation protocol on an I/O stream
are distinguished by their role as a <em>dialer</em> (or <em>initiator</em>) or as a <em>listener</em>
(or <em>responder</em>). Thereby the dialer plays the active part, driving the protocol,
whereas the listener reacts to the messages received.</p>
<p>The dialer has two options: it can either pick a protocol from the complete list
of protocols that the listener supports, or it can directly suggest a protocol.
Either way, a selected protocol is sent to the listener who can either accept (by
echoing the same protocol) or reject (by responding with a message stating
“not available”). If a suggested protocol is not available, the dialer may
suggest another protocol. This process continues until a protocol is agreed upon,
yielding a <a href="struct.Negotiated.html"><code>Negotiated</code></a> stream, or the dialer has run out of
alternatives.</p>
<p>See <a href="fn.dialer_select_proto.html"><code>dialer_select_proto</code></a> and
<a href="fn.listener_select_proto.html"><code>listener_select_proto</code></a>.</p>
<h3 id="negotiated" class="section-header"><a href="#negotiated"><code>Negotiated</code></a></h3>
<p>A <code>Negotiated</code> represents an I/O stream that has settled on a protocol
to use. By default, with <a href="enum.Version.html#variant.V1" title="Version::V1"><code>Version::V1</code></a>, protocol negotiation is always
at least one dedicated round-trip message exchange, before application
data for the negotiated protocol can be sent by the dialer. There is
a variant <a href="enum.Version.html#variant.V1Lazy" title="Version::V1Lazy"><code>Version::V1Lazy</code></a> that permits 0-RTT negotiation if the
dialer only supports a single protocol. In that case, when a dialer
settles on a protocol to use, the <a href="type.DialerSelectFuture.html" title="DialerSelectFuture"><code>DialerSelectFuture</code></a> yields a
<a href="struct.Negotiated.html"><code>Negotiated</code></a> I/O stream before the negotiation
data has been flushed. It is then expecting confirmation for that protocol
as the first messages read from the stream. This behaviour allows the dialer
to immediately send data relating to the negotiated protocol together with the
remaining negotiation message(s). Note, however, that a dialer that performs
multiple 0-RTT negotiations in sequence for different protocols layered on
top of each other may trigger undesirable behaviour for a listener not
supporting one of the intermediate protocols. See
<a href="fn.dialer_select_proto.html"><code>dialer_select_proto</code></a> and the documentation
of <a href="enum.Version.html#variant.V1Lazy" title="Version::V1Lazy"><code>Version::V1Lazy</code></a> for further details.</p>
<h3 id="examples" class="section-header"><a href="#examples">Examples</a></h3>
<p>For a dialer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">async_std::net::TcpStream</span>;
<span class="kw">use</span> <span class="ident">multistream_select</span>::{<span class="ident">dialer_select_proto</span>, <span class="ident">Version</span>};
<span class="kw">use</span> <span class="ident">futures::prelude</span>::<span class="kw-2">*</span>;

<span class="ident">async_std::task::block_on</span>(<span class="kw">async</span> <span class="kw">move</span> {
    <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">TcpStream::connect</span>(<span class="string">&quot;127.0.0.1:10333&quot;</span>).<span class="kw">await</span>.<span class="ident">unwrap</span>();

    <span class="kw">let</span> <span class="ident">protos</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="string">b&quot;/echo/1.0.0&quot;</span>, <span class="string">b&quot;/echo/2.5.0&quot;</span>];
    <span class="kw">let</span> (<span class="ident">protocol</span>, <span class="ident">_io</span>) <span class="op">=</span> <span class="ident">dialer_select_proto</span>(<span class="ident">socket</span>, <span class="ident">protos</span>, <span class="ident">Version::V1</span>).<span class="kw">await</span>.<span class="ident">unwrap</span>();

    <span class="macro">println!</span>(<span class="string">&quot;Negotiated protocol: {:?}&quot;</span>, <span class="ident">protocol</span>);
    <span class="comment">// You can now use `_io` to communicate with the remote.</span>
});</code></pre></div>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ListenerSelectFuture.html" title="multistream_select::ListenerSelectFuture struct">ListenerSelectFuture</a></div><div class="item-right docblock-short"><p>The <code>Future</code> returned by <a href="fn.listener_select_proto.html" title="listener_select_proto"><code>listener_select_proto</code></a> that performs a
multistream-select protocol negotiation on an underlying I/O stream.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Negotiated.html" title="multistream_select::Negotiated struct">Negotiated</a></div><div class="item-right docblock-short"><p>An I/O stream that has settled on an (application-layer) protocol to use.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NegotiatedComplete.html" title="multistream_select::NegotiatedComplete struct">NegotiatedComplete</a></div><div class="item-right docblock-short"><p>A <code>Future</code> that waits on the completion of protocol negotiation.</p>
</div></div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.NegotiationError.html" title="multistream_select::NegotiationError enum">NegotiationError</a></div><div class="item-right docblock-short"><p>Error that can happen when negotiating a protocol with the remote.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ProtocolError.html" title="multistream_select::ProtocolError enum">ProtocolError</a></div><div class="item-right docblock-short"><p>A protocol error.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Version.html" title="multistream_select::Version enum">Version</a></div><div class="item-right docblock-short"><p>Supported multistream-select versions.</p>
</div></div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.dialer_select_proto.html" title="multistream_select::dialer_select_proto fn">dialer_select_proto</a></div><div class="item-right docblock-short"><p>Returns a <code>Future</code> that negotiates a protocol on the given I/O stream
for a peer acting as the <em>dialer</em> (or <em>initiator</em>).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.listener_select_proto.html" title="multistream_select::listener_select_proto fn">listener_select_proto</a></div><div class="item-right docblock-short"><p>Returns a <code>Future</code> that negotiates a protocol on the given I/O stream
for a peer acting as the <em>listener</em> (or <em>responder</em>).</p>
</div></div></div><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.DialerSelectFuture.html" title="multistream_select::DialerSelectFuture type">DialerSelectFuture</a></div><div class="item-right docblock-short"><p>Future, returned by <code>dialer_select_proto</code>, which selects a protocol and dialer
either trying protocols in-order, or by requesting all protocols supported
by the remote upfront, from which the first protocol found in the dialer’s
list of protocols is selected.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="multistream_select" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>