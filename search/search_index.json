{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Polkadot ecosystem index for investors. A self-sustaining auction treasury for parachains. \u00b6 The Polkadot Index Network Token (PINT) is a token that enables protocols and individuals to easily gain diversified exposure to the top Polkadot ecosystem projects. Holders are exposed to the price movements and rewards of all of the assets within the PINT index. While many people (even the professionals) believe they should actively manage their portfolios, investing in an index is the best choice for most investors - just ask Warren Buffet. Index funds are popular because they enable ownership of a wide variety of assets, providing immediate diversification and lower risk. PINT operates as a DAO within the StakerDAO ecosystem, governed by a council of Polkadot ecosystem participants. Council Members Company Ruitao Su, Co-Founder & CEO Acala & Laminar Xiao Xiao, Investment Manager HashKey Capital Jack Platts, Co-Founder & CEO Hypersphere Ventures Benjamin Weiss, Substrate Builders Program Parity Technologies Ben Perszyk, Head of Portfolio Ops, Polkadot Ecosystem Fund Lead Polychain Capital Graham Tonkin, Co-Founder Stateless.Money Validator Open Seat for PINT Community Member One of the key features of the Polkadot ecosystem is the ability for projects to build use-case-specific \"parachains\". Parachains are self-sovereign blockchains that can interoperate with one another while benefiting from the security of the base Polkadot relay chain. This interoperability creates a commonwealth of sorts, providing unique benefits to projects building within the Polkadot ecosystem. \u200cThe Polkadot relay chain abstracts away many of the technical complexities present when building \"stand-alone\" blockchains. Similar to how Amazon Web Services removed the need for individual companies to maintain a rack of servers and the staff to support them in each office, the Polkadot relay chain removes the necessity to employ cryptographers, runtime engineers, and protocol-level specialists. This enables parachains to focus on their core use-case and govern by their own rules, while the relay chain remains optimized to secure and settle the network. One hundred parachain slots will be available for parachain candidates to compete for via the Parachain Lease Offering (PLO) process. Each prospective parachain candidate must generate sufficient financing to secure the slot and maintain the lease on an ongoing basis. Additionally, many of the parachains will be managed via a permissionless and transparent \u201con-chain\u201d governance process. This model creates a challenge for parachain communities which may impact the stability and growth of the Polkadot ecosystem: Treasury Management - Communities will need to consider how the funds held in their treasury are managed. If a protocol holds only their native asset, the risk of volatility may impact the long-term viability of their parachain slot or ability to finance ongoing development. While the relay chain enables them to focus on their core business case, not all projects will have the expertise or desire to actively manage the funds held in their treasury. Ongoing PLO Financing - Parachains may find it difficult to maintain their slot for sustained periods of time (e.g after the 4th auction) once token treasuries are depleted from airdrops and when competing with new, more speculative projects that have significant marketing budgets. PINT will enable any person or protocol to gain diversified exposure to the top projects in the Polkadot ecosystem in a transparent and permissionless way. Protocols approved to join the index by PINT governance will benefit from; A reduction in treasury risk - Each protocol community may choose to exchange a portion of their treasury for PINT, an index that consists of the top projects in the ecosystem, governed by reputable ecosystem professionals. This reduces the need for active treasury manangement. Ensuring governance quorums are met - The PINT council will participate in the governance of assets in the index. PLO Financing - Constituent communities will have the ability to apply for financing from the PINT treasury. Increased token demand - Investors looking to gain diversified ecosystem exposure will increase the demand for tokens in the index. PINT Docs is an evolving set of documents and resources to help you understand PINT, the Polkadot ecosystem, and how to build and interact with PINT. If you are already familiar with PINT and the Polkadot ecosystem, or you just want to dive in, head over to Get Started . Connect \u00b6 Let us know if you have any feedback or ideas that might help us improve our documentation or if you have any resources that you would like to see added. If you are planning to use PINT or any of the PINT pallets, please say hello! General Resources \u00b6 Architecture \u00b6 Installation \u00b6 Configuration \u00b6 Developer Resources \u00b6 Command Line: \u00b6 Testing and Debugging: \u00b6 ## Test Suite ## Debugging ## Overview","title":"Overview"},{"location":"#a-polkadot-ecosystem-index-for-investors-a-self-sustaining-auction-treasury-for-parachains","text":"The Polkadot Index Network Token (PINT) is a token that enables protocols and individuals to easily gain diversified exposure to the top Polkadot ecosystem projects. Holders are exposed to the price movements and rewards of all of the assets within the PINT index. While many people (even the professionals) believe they should actively manage their portfolios, investing in an index is the best choice for most investors - just ask Warren Buffet. Index funds are popular because they enable ownership of a wide variety of assets, providing immediate diversification and lower risk. PINT operates as a DAO within the StakerDAO ecosystem, governed by a council of Polkadot ecosystem participants. Council Members Company Ruitao Su, Co-Founder & CEO Acala & Laminar Xiao Xiao, Investment Manager HashKey Capital Jack Platts, Co-Founder & CEO Hypersphere Ventures Benjamin Weiss, Substrate Builders Program Parity Technologies Ben Perszyk, Head of Portfolio Ops, Polkadot Ecosystem Fund Lead Polychain Capital Graham Tonkin, Co-Founder Stateless.Money Validator Open Seat for PINT Community Member One of the key features of the Polkadot ecosystem is the ability for projects to build use-case-specific \"parachains\". Parachains are self-sovereign blockchains that can interoperate with one another while benefiting from the security of the base Polkadot relay chain. This interoperability creates a commonwealth of sorts, providing unique benefits to projects building within the Polkadot ecosystem. \u200cThe Polkadot relay chain abstracts away many of the technical complexities present when building \"stand-alone\" blockchains. Similar to how Amazon Web Services removed the need for individual companies to maintain a rack of servers and the staff to support them in each office, the Polkadot relay chain removes the necessity to employ cryptographers, runtime engineers, and protocol-level specialists. This enables parachains to focus on their core use-case and govern by their own rules, while the relay chain remains optimized to secure and settle the network. One hundred parachain slots will be available for parachain candidates to compete for via the Parachain Lease Offering (PLO) process. Each prospective parachain candidate must generate sufficient financing to secure the slot and maintain the lease on an ongoing basis. Additionally, many of the parachains will be managed via a permissionless and transparent \u201con-chain\u201d governance process. This model creates a challenge for parachain communities which may impact the stability and growth of the Polkadot ecosystem: Treasury Management - Communities will need to consider how the funds held in their treasury are managed. If a protocol holds only their native asset, the risk of volatility may impact the long-term viability of their parachain slot or ability to finance ongoing development. While the relay chain enables them to focus on their core business case, not all projects will have the expertise or desire to actively manage the funds held in their treasury. Ongoing PLO Financing - Parachains may find it difficult to maintain their slot for sustained periods of time (e.g after the 4th auction) once token treasuries are depleted from airdrops and when competing with new, more speculative projects that have significant marketing budgets. PINT will enable any person or protocol to gain diversified exposure to the top projects in the Polkadot ecosystem in a transparent and permissionless way. Protocols approved to join the index by PINT governance will benefit from; A reduction in treasury risk - Each protocol community may choose to exchange a portion of their treasury for PINT, an index that consists of the top projects in the ecosystem, governed by reputable ecosystem professionals. This reduces the need for active treasury manangement. Ensuring governance quorums are met - The PINT council will participate in the governance of assets in the index. PLO Financing - Constituent communities will have the ability to apply for financing from the PINT treasury. Increased token demand - Investors looking to gain diversified ecosystem exposure will increase the demand for tokens in the index. PINT Docs is an evolving set of documents and resources to help you understand PINT, the Polkadot ecosystem, and how to build and interact with PINT. If you are already familiar with PINT and the Polkadot ecosystem, or you just want to dive in, head over to Get Started .","title":"A Polkadot ecosystem index for investors. A self-sustaining auction treasury for parachains."},{"location":"#connect","text":"Let us know if you have any feedback or ideas that might help us improve our documentation or if you have any resources that you would like to see added. If you are planning to use PINT or any of the PINT pallets, please say hello!","title":"Connect"},{"location":"#general-resources","text":"","title":"General Resources"},{"location":"#architecture","text":"","title":"Architecture"},{"location":"#installation","text":"","title":"Installation"},{"location":"#configuration","text":"","title":"Configuration"},{"location":"#developer-resources","text":"","title":"Developer Resources"},{"location":"#command-line","text":"","title":"Command Line:"},{"location":"#testing-and-debugging","text":"## Test Suite ## Debugging ## Overview","title":"Testing and Debugging:"},{"location":"api/SourceSerif4-LICENSE/","text":"Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007 \u00b6 PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others. The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives. DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation. \"Reserved Font Name\" refers to any names specified as such after the copyright statement(s). \"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s). \"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment. \"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software. PERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions: 1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself. 2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user. 3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users. 4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission. 5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software. TERMINATION This license becomes null and void if any of the above conditions are not met. DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","title":"SourceSerif4 LICENSE"},{"location":"api/SourceSerif4-LICENSE/#sil-open-font-license-version-11-26-february-2007","text":"PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others. The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives. DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation. \"Reserved Font Name\" refers to any names specified as such after the copyright statement(s). \"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s). \"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment. \"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software. PERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions: 1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself. 2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user. 3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users. 4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission. 5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software. TERMINATION This license becomes null and void if any of the above conditions are not met. DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007"},{"location":"getting-started/installation/","text":"Get Started \u00b6 Prerequisites \u00b6 This project currently builds against Rust nightly-2021-08-01. Assuming you have rustup already insatlled set up your local environment: rustup install nightly-2021-08-01 rustup target add wasm32-unknown-unknown --toolchain nightly-2021-08-01 rustup override set nightly-2021-08-01 Build \u00b6 Once the development environment is set up, build the node template. This command will build the Wasm and native code: cargo build --release Note: If the build fails with (signal: 9, SIGKILL: kill) it has probably run out of memory. Try freeing some memory or build on another machine. Run \u00b6 Development Chain \u00b6 You can start a standalone development chain with: cargo run -- --dev --instant-sealing Or if already built: ./target/release/pint --dev --instant-sealing For docker : docker run chainsafe/pint --dev --instant-sealing This will use the node/src/chain_spec/dev.rs chain spec. Local Testnet \u00b6 Polkadot (release-v0.9.x branch) cargo build --release ./target/release/polkadot build-spec --chain rococo-local --raw --disable-default-bootnode > rococo_local.json ./target/release/polkadot --chain ./rococo_local.json -d cumulus_relay0 --validator --alice --port 9844 ./target/release/polkadot --chain ./rococo_local.json -d cumulus_relay1 --validator --bob --port 9955 PINT Parachain: \u00b6 # this command assumes the chain spec is in a directory named polkadot that is a sibling of the pint directory ./target/release/pint --collator --alice --chain pint-dev --ws-port 9945 --parachain-id 200 --rpc-cors all -- --execution wasm --chain ../polkadot/rococo_local.json --ws-port 9977 --rpc-cors all Registering on Local Relay Chain \u00b6 In order to produce blocks you will need to register the parachain as detailed in the Substrate Cumulus Workshop by going to Developer -> sudo -> paraSudoWrapper -> sudoScheduleParaInitialize(id, genesis) Ensure you set the ParaId to 200 and the parachain: Bool to Yes . cargo build -- release # Build the Chain spec ./ target / release / pint build - spec -- chain = pint - dev -- disable - default - bootnode > ./ pint - local - plain . json # Build the raw file ./ target / release / pint build - spec -- chain =./ pint - local - plain . json -- raw -- disable - default - bootnode > ./ pint - local . json # export genesis state and wasm ./ target / release / pint export - genesis - state -- chain = pint - dev -- parachain - id 200 > para - 200 - genesis ./ target / release / pint export - genesis - wasm -- chain = pint - dev > ./ para - 200. wasm Start a Parachain Node (Collator) \u00b6 From the parachain template working directory: # This assumes a ParaId of 200. Change as needed. ./target/release/pint \\ -d /tmp/parachain/alice \\ --collator \\ --alice \\ --force-authoring \\ --ws-port 9945 \\ --parachain-id 200 \\ -- \\ --execution wasm \\ --chain pint_local.json polkadot-launch can be run by dropping the proper polkadot binary in the ./bin folder and Run globally polkadot-launch config.json Run locally, navigate into polkadot-launch, yarn yarn start Test \u00b6 Testing PINT with cargo \u00b6 cargo test --all-features Will run the tests of PINT with cargo. Testing PINT with polkadot.js \u00b6 # the e2e tests require `polkadot-launch` as a git submodule git submodule update --recursive # install dependencies and run e2e tests cd js && yarn && yarn e2e Will bootstrap PINT with polkadot-launch and run all calls of PINT with polkadot.js to test both PINT can connect to rococo and PINT calls are workable with polkadot.js . Learn More \u00b6 More detailed instructions to use Cumulus parachains are found in the Cumulus Workshop . Refer to the upstream Substrate Node Template to learn more about the structure of this project, the capabilities it encapsulates and the way in which those capabilities are implemented. Learn more about how a parachain block is added to a finalized chain here .","title":"Installation"},{"location":"getting-started/installation/#get-started","text":"","title":"Get Started"},{"location":"getting-started/installation/#prerequisites","text":"This project currently builds against Rust nightly-2021-08-01. Assuming you have rustup already insatlled set up your local environment: rustup install nightly-2021-08-01 rustup target add wasm32-unknown-unknown --toolchain nightly-2021-08-01 rustup override set nightly-2021-08-01","title":"Prerequisites"},{"location":"getting-started/installation/#build","text":"Once the development environment is set up, build the node template. This command will build the Wasm and native code: cargo build --release Note: If the build fails with (signal: 9, SIGKILL: kill) it has probably run out of memory. Try freeing some memory or build on another machine.","title":"Build"},{"location":"getting-started/installation/#run","text":"","title":"Run"},{"location":"getting-started/installation/#development-chain","text":"You can start a standalone development chain with: cargo run -- --dev --instant-sealing Or if already built: ./target/release/pint --dev --instant-sealing For docker : docker run chainsafe/pint --dev --instant-sealing This will use the node/src/chain_spec/dev.rs chain spec.","title":"Development Chain"},{"location":"getting-started/installation/#local-testnet","text":"Polkadot (release-v0.9.x branch) cargo build --release ./target/release/polkadot build-spec --chain rococo-local --raw --disable-default-bootnode > rococo_local.json ./target/release/polkadot --chain ./rococo_local.json -d cumulus_relay0 --validator --alice --port 9844 ./target/release/polkadot --chain ./rococo_local.json -d cumulus_relay1 --validator --bob --port 9955","title":"Local Testnet"},{"location":"getting-started/installation/#pint-parachain","text":"# this command assumes the chain spec is in a directory named polkadot that is a sibling of the pint directory ./target/release/pint --collator --alice --chain pint-dev --ws-port 9945 --parachain-id 200 --rpc-cors all -- --execution wasm --chain ../polkadot/rococo_local.json --ws-port 9977 --rpc-cors all","title":"PINT Parachain:"},{"location":"getting-started/installation/#registering-on-local-relay-chain","text":"In order to produce blocks you will need to register the parachain as detailed in the Substrate Cumulus Workshop by going to Developer -> sudo -> paraSudoWrapper -> sudoScheduleParaInitialize(id, genesis) Ensure you set the ParaId to 200 and the parachain: Bool to Yes . cargo build -- release # Build the Chain spec ./ target / release / pint build - spec -- chain = pint - dev -- disable - default - bootnode > ./ pint - local - plain . json # Build the raw file ./ target / release / pint build - spec -- chain =./ pint - local - plain . json -- raw -- disable - default - bootnode > ./ pint - local . json # export genesis state and wasm ./ target / release / pint export - genesis - state -- chain = pint - dev -- parachain - id 200 > para - 200 - genesis ./ target / release / pint export - genesis - wasm -- chain = pint - dev > ./ para - 200. wasm","title":"Registering on Local Relay Chain"},{"location":"getting-started/installation/#start-a-parachain-node-collator","text":"From the parachain template working directory: # This assumes a ParaId of 200. Change as needed. ./target/release/pint \\ -d /tmp/parachain/alice \\ --collator \\ --alice \\ --force-authoring \\ --ws-port 9945 \\ --parachain-id 200 \\ -- \\ --execution wasm \\ --chain pint_local.json polkadot-launch can be run by dropping the proper polkadot binary in the ./bin folder and Run globally polkadot-launch config.json Run locally, navigate into polkadot-launch, yarn yarn start","title":"Start a Parachain Node (Collator)"},{"location":"getting-started/installation/#test","text":"","title":"Test"},{"location":"getting-started/installation/#testing-pint-with-cargo","text":"cargo test --all-features Will run the tests of PINT with cargo.","title":"Testing PINT with cargo"},{"location":"getting-started/installation/#testing-pint-with-polkadotjs","text":"# the e2e tests require `polkadot-launch` as a git submodule git submodule update --recursive # install dependencies and run e2e tests cd js && yarn && yarn e2e Will bootstrap PINT with polkadot-launch and run all calls of PINT with polkadot.js to test both PINT can connect to rococo and PINT calls are workable with polkadot.js .","title":"Testing PINT with polkadot.js"},{"location":"getting-started/installation/#learn-more","text":"More detailed instructions to use Cumulus parachains are found in the Cumulus Workshop . Refer to the upstream Substrate Node Template to learn more about the structure of this project, the capabilities it encapsulates and the way in which those capabilities are implemented. Learn more about how a parachain block is added to a finalized chain here .","title":"Learn More"},{"location":"getting-started/overview/architecture/","text":"Architecture \u00b6 This document describes the high-level architecture of the PINT codebase. You might also find the higher-level conceptual documentation of PINT helpful: docs.polkadotindex.com See also these implementation-related community blog posts: https://polkadotindex.substack.com/p/pint-update-1 https://polkadotindex.substack.com/p/pint-community-update-2 Terminology \u00b6 SAFT ( Simple Agreement for Future Token ) represent asset contributions (from project) that may become liquid tokens in the future. Their value will be updated regularly NAV ( Net Asset Value ) represents: the net value of an asset in the index and is calculated by multiplying the per-unit price with the total amount of tokens held in the index. In the context of the index token itself (PINT) this however represents the unit value of the token and is calculated by taking the value of each of the underlying tokens over the total supply of PINT: Pallets \u00b6 All custom PINT pallets are located in the pallets folder in the root of the repository which includes. Committee Pallet \u00b6 This includes the core governance mechanics. PINT Governance will be administered in two layers: the PINT Council, and the Constituent Committee. However, we treat both holistically as a Committee within the code base. The pallet includes a set of privileged accounts that are either of type MemberType::Council or MemberType::Constituent . Voting \u00b6 All proposals are described as dispatchable calls, which means that any method on any other pallet can be executed as the result of a proposal. For example, a proposal to transfer 100 PINT to a community member from the treasury would take the form of a call to the Treasury pallet: Treasury::withdraw(recipient, 100) . Proposals need to reach a majority within a certain voting period for them to be executable. Local Treasury Pallet \u00b6 Manages PINT exclusively. The treasury is a single account which is derived from the configured PalletId . It maintains ownership of various assets and is controlled by the Governance Committee. Deposits to the Treasury can be done by simply transferring funds to its AccountId. The committee can execute proposals to withdraw funds from the Treasury. Remote Treasury Pallet \u00b6 Similar to the local treasury, but this pallet will be responsible for DOT (or other liquid assets in the Network). It will execute withdrawals via XCM. Price feed Pallet \u00b6 In order to exchange assets for PINT, the value of those assets as well as PINT\u2019s NAV needs to be computed. This pallet is an abstraction over the chainlink-feed-pallet which provides oracle data from the chainlink network. It provides a lookup table for mapping PINT internal asset identifiers with the chainlink pallet internal price feed identifiers ( AssetId -> FeedId ). Since the NAV calculation requires that all asset values are measured in the same currency. All price feeds are expected to be configured with the same quote currency (e.g. USD). This currency will then also be the currency the NAV is measured in, since the NAV of the index is then PINT/USD , effectively the on-chain price of PINT. Note: All the core functionality of the asset-index , like depositing and redeeming, relies on price feeds and a mapping from AssetId -> ChainlinkFeed in the price-feed pallet. The chainlink pallet is managed by the PalletAdmin account which can assign accounts the role of FeedCreator . In the pint-dev chainspec Alice is the PalletAdmin and the council accounts ( Alice , Bob , Charlie , Dave ) are FeedCreators and are allowed to create feeds. SAFT Registry Pallet \u00b6 This pallet consists of records of off-chain SAFTs. An SAFT asset can have multiple SAFT Records. Each SAFTRecord holds the number of units of its asset and their value. This value is expected to in the same currency the liquid assets use for their price feeds, so that the NAV can easily be calculated according to the NAV formula. The SAFT registry pallet requires the AssetRecorder trait which is an abstraction over the features for adding/removing assets, which is implemented for the AssetIndex . Adding a SAFT record will call into the AssetRecorder::add_saft function, in mints new PINT according to the value of the SAFT record. SAFTs can be converted to liquid tokens once they're available in the network with a location. Asset Index Pallet \u00b6 This pallet provides all user facing extrinsics for depositing assets ( AssetIndex::deposit ) and redeeming PINT ( AssetIndex::withdraw ). It provides all NAV related calculations which is abstracted over the NavProvider trait. Assets are distinguished by their kind, either they are liquid, or SAFT. The value of liquid assets will be calculated using the price feeds whereas the value of a SAFT asset is determined by the total value of all SAFT records. Since the SAFT records are stored in the SaftRegistry the AssetIndex requires the SaftRegistry trait abstraction for that. Depositing \u00b6 Any user may deposit liquid assets. A new liquid asset class is created either by registering it with its native location in the network ( AssetIndex::register ) or by being added via ( AssetIndex::add_asset ). In order to be able to deposit, a user must first send liquid assets (e.g.) from its native location (e.g. relay chain) to PINT, upon which it gets stored in the user personal MultiCurrency balance. This process will be handled by the LocalAssetTransactor configured in the runtime which transacts incoming Xcm::Deposit messages into deposit into the sender's MultiCurrency balance for that very asset. Since deposit is fallible this is a 2-step process: send x amount of liquid asset A from chain A to PINT. call AssetIndex::deposit(A, x) The deposit call determines how much PINT the amount is worth and transfers the asset amount to the index account and mints PINT in exchange into the caller's PINT balance. The total value of the index increases by the value of the deposited amount, but the NAV will stay consistent since the newly minted PINT will counteract that. Withdrawing \u00b6 All new deposits (received PINT) are locked for a certain period and timestamped to calculate withdrawal fees based on time spent in the index. After the LockupPeriod is over PINT can be redeemed by the user for a distribution of the underlying liquid assets. The liquid assets in the index are awarded to the redeemer, totalling the value of the redeemed PINT, but in proportion to their representation in the index. This will lock the pending withdrawals for a certain WithdrawalPeriod kick off the unbonding process in which the RemoteAssetManager will ensure that the pending withdrawals are available on their native location. If for example a pending withdrawal exceeds the amount held as a reserve (e.g. not staked) then they need to be unbonded first. After the WithdrawalPeriod a user may try to complete their withdrawals ( AssetIndex::complete_withdrawal ), which will try to complete every single AssetWithdrawal but it will only get closed entirely after the last AssetWithdrawal was completed. Remote Asset Manager Pallet \u00b6 This pallet provides all the cross chain capabilities PINT relies on. Most importantly bonding and unbonding liquid assets. Remote Staking is still experimental and rather complex endeavor. The remote asset manager comes with bindings for the substrate FRAME pallet_staking . Assets that were sent to PINT using XCM reserved based transfer are kept in an account derived from PINT's parachain ID (sovereign account) to which only the PINT parachain has access to during XCM execution. In other words, all liquid assets that were deposited to the index (e.g. DOT) are sitting in an account on the asset's native location (e.g. relay chain) to which the PINT parachain has access via XCM. Withdrawing an amount of liquid assets from PINT, will then transfer the amount from this account back to recipient included in the destination of the XCM message. XCM also supports dispatching calls on other chains whose origin then will be the sovereign account of the parachain. This means funds held in PINT's sovereign account can be staked by calling the necessary functions of the staking pallet, staked assets are called active , the default is idle . In order to execute a Xcm::Transact the payload (dispatchable) must be encoded as it would be represented by the Call enum of the runtime of the xcm's destination. The encoding of a dispatchable call in the Runtime::Call enum is further dependent on the index of the pallet as it is configured in the construct_runtime! macro. To make things worse, the encoding of course depends on the runtime specific types. So in order to generalize remote staking it is required that: the index of pallet_staking in the runtime is known the remote asset manager can encode the runtime specific types. For the pallet_staking these are: AccountId , Balance , LookupSource . The remote handles this by requiring the StakingCallEncoder type, which takes care of asset specific encoding of pallet_staking dispatchables. It also has experimental support for transferring PINT to Statemint parachain","title":"Architecture"},{"location":"getting-started/overview/architecture/#architecture","text":"This document describes the high-level architecture of the PINT codebase. You might also find the higher-level conceptual documentation of PINT helpful: docs.polkadotindex.com See also these implementation-related community blog posts: https://polkadotindex.substack.com/p/pint-update-1 https://polkadotindex.substack.com/p/pint-community-update-2","title":"Architecture"},{"location":"getting-started/overview/architecture/#terminology","text":"SAFT ( Simple Agreement for Future Token ) represent asset contributions (from project) that may become liquid tokens in the future. Their value will be updated regularly NAV ( Net Asset Value ) represents: the net value of an asset in the index and is calculated by multiplying the per-unit price with the total amount of tokens held in the index. In the context of the index token itself (PINT) this however represents the unit value of the token and is calculated by taking the value of each of the underlying tokens over the total supply of PINT:","title":"Terminology"},{"location":"getting-started/overview/architecture/#pallets","text":"All custom PINT pallets are located in the pallets folder in the root of the repository which includes.","title":"Pallets"},{"location":"getting-started/overview/architecture/#committee-pallet","text":"This includes the core governance mechanics. PINT Governance will be administered in two layers: the PINT Council, and the Constituent Committee. However, we treat both holistically as a Committee within the code base. The pallet includes a set of privileged accounts that are either of type MemberType::Council or MemberType::Constituent .","title":"Committee Pallet"},{"location":"getting-started/overview/architecture/#voting","text":"All proposals are described as dispatchable calls, which means that any method on any other pallet can be executed as the result of a proposal. For example, a proposal to transfer 100 PINT to a community member from the treasury would take the form of a call to the Treasury pallet: Treasury::withdraw(recipient, 100) . Proposals need to reach a majority within a certain voting period for them to be executable.","title":"Voting"},{"location":"getting-started/overview/architecture/#local-treasury-pallet","text":"Manages PINT exclusively. The treasury is a single account which is derived from the configured PalletId . It maintains ownership of various assets and is controlled by the Governance Committee. Deposits to the Treasury can be done by simply transferring funds to its AccountId. The committee can execute proposals to withdraw funds from the Treasury.","title":"Local Treasury Pallet"},{"location":"getting-started/overview/architecture/#remote-treasury-pallet","text":"Similar to the local treasury, but this pallet will be responsible for DOT (or other liquid assets in the Network). It will execute withdrawals via XCM.","title":"Remote Treasury Pallet"},{"location":"getting-started/overview/architecture/#price-feed-pallet","text":"In order to exchange assets for PINT, the value of those assets as well as PINT\u2019s NAV needs to be computed. This pallet is an abstraction over the chainlink-feed-pallet which provides oracle data from the chainlink network. It provides a lookup table for mapping PINT internal asset identifiers with the chainlink pallet internal price feed identifiers ( AssetId -> FeedId ). Since the NAV calculation requires that all asset values are measured in the same currency. All price feeds are expected to be configured with the same quote currency (e.g. USD). This currency will then also be the currency the NAV is measured in, since the NAV of the index is then PINT/USD , effectively the on-chain price of PINT. Note: All the core functionality of the asset-index , like depositing and redeeming, relies on price feeds and a mapping from AssetId -> ChainlinkFeed in the price-feed pallet. The chainlink pallet is managed by the PalletAdmin account which can assign accounts the role of FeedCreator . In the pint-dev chainspec Alice is the PalletAdmin and the council accounts ( Alice , Bob , Charlie , Dave ) are FeedCreators and are allowed to create feeds.","title":"Price feed Pallet"},{"location":"getting-started/overview/architecture/#saft-registry-pallet","text":"This pallet consists of records of off-chain SAFTs. An SAFT asset can have multiple SAFT Records. Each SAFTRecord holds the number of units of its asset and their value. This value is expected to in the same currency the liquid assets use for their price feeds, so that the NAV can easily be calculated according to the NAV formula. The SAFT registry pallet requires the AssetRecorder trait which is an abstraction over the features for adding/removing assets, which is implemented for the AssetIndex . Adding a SAFT record will call into the AssetRecorder::add_saft function, in mints new PINT according to the value of the SAFT record. SAFTs can be converted to liquid tokens once they're available in the network with a location.","title":"SAFT Registry Pallet"},{"location":"getting-started/overview/architecture/#asset-index-pallet","text":"This pallet provides all user facing extrinsics for depositing assets ( AssetIndex::deposit ) and redeeming PINT ( AssetIndex::withdraw ). It provides all NAV related calculations which is abstracted over the NavProvider trait. Assets are distinguished by their kind, either they are liquid, or SAFT. The value of liquid assets will be calculated using the price feeds whereas the value of a SAFT asset is determined by the total value of all SAFT records. Since the SAFT records are stored in the SaftRegistry the AssetIndex requires the SaftRegistry trait abstraction for that.","title":"Asset Index Pallet"},{"location":"getting-started/overview/architecture/#depositing","text":"Any user may deposit liquid assets. A new liquid asset class is created either by registering it with its native location in the network ( AssetIndex::register ) or by being added via ( AssetIndex::add_asset ). In order to be able to deposit, a user must first send liquid assets (e.g.) from its native location (e.g. relay chain) to PINT, upon which it gets stored in the user personal MultiCurrency balance. This process will be handled by the LocalAssetTransactor configured in the runtime which transacts incoming Xcm::Deposit messages into deposit into the sender's MultiCurrency balance for that very asset. Since deposit is fallible this is a 2-step process: send x amount of liquid asset A from chain A to PINT. call AssetIndex::deposit(A, x) The deposit call determines how much PINT the amount is worth and transfers the asset amount to the index account and mints PINT in exchange into the caller's PINT balance. The total value of the index increases by the value of the deposited amount, but the NAV will stay consistent since the newly minted PINT will counteract that.","title":"Depositing"},{"location":"getting-started/overview/architecture/#withdrawing","text":"All new deposits (received PINT) are locked for a certain period and timestamped to calculate withdrawal fees based on time spent in the index. After the LockupPeriod is over PINT can be redeemed by the user for a distribution of the underlying liquid assets. The liquid assets in the index are awarded to the redeemer, totalling the value of the redeemed PINT, but in proportion to their representation in the index. This will lock the pending withdrawals for a certain WithdrawalPeriod kick off the unbonding process in which the RemoteAssetManager will ensure that the pending withdrawals are available on their native location. If for example a pending withdrawal exceeds the amount held as a reserve (e.g. not staked) then they need to be unbonded first. After the WithdrawalPeriod a user may try to complete their withdrawals ( AssetIndex::complete_withdrawal ), which will try to complete every single AssetWithdrawal but it will only get closed entirely after the last AssetWithdrawal was completed.","title":"Withdrawing"},{"location":"getting-started/overview/architecture/#remote-asset-manager-pallet","text":"This pallet provides all the cross chain capabilities PINT relies on. Most importantly bonding and unbonding liquid assets. Remote Staking is still experimental and rather complex endeavor. The remote asset manager comes with bindings for the substrate FRAME pallet_staking . Assets that were sent to PINT using XCM reserved based transfer are kept in an account derived from PINT's parachain ID (sovereign account) to which only the PINT parachain has access to during XCM execution. In other words, all liquid assets that were deposited to the index (e.g. DOT) are sitting in an account on the asset's native location (e.g. relay chain) to which the PINT parachain has access via XCM. Withdrawing an amount of liquid assets from PINT, will then transfer the amount from this account back to recipient included in the destination of the XCM message. XCM also supports dispatching calls on other chains whose origin then will be the sovereign account of the parachain. This means funds held in PINT's sovereign account can be staked by calling the necessary functions of the staking pallet, staked assets are called active , the default is idle . In order to execute a Xcm::Transact the payload (dispatchable) must be encoded as it would be represented by the Call enum of the runtime of the xcm's destination. The encoding of a dispatchable call in the Runtime::Call enum is further dependent on the index of the pallet as it is configured in the construct_runtime! macro. To make things worse, the encoding of course depends on the runtime specific types. So in order to generalize remote staking it is required that: the index of pallet_staking in the runtime is known the remote asset manager can encode the runtime specific types. For the pallet_staking these are: AccountId , Balance , LookupSource . The remote handles this by requiring the StakingCallEncoder type, which takes care of asset specific encoding of pallet_staking dispatchables. It also has experimental support for transferring PINT to Statemint parachain","title":"Remote Asset Manager Pallet"},{"location":"getting-started/resources/developer-resources/","text":"Cryptography \u00b6 blake2s used for hashing ed25519 (signing) ed25519 (curve) WASM \u00b6 WASM Specification Wasm on the Blockchain: The Lesser Evil [blog post] Polkadot \u00b6 Polkadot Wiki Polkadot Consensus Wiki Polkadot Runtime Environment Specification (Section 8.2) Rust Docs: finality_grandpa paritytech/finality_grandpa The State of Crypto Interoperability Explained in Pictures Parachains \u00b6 The Parachain (Blog Post) Parachains on Polkadot Wiki Parathreads (Blog Post) Parathreads on Polkadot Wiki The Path of a Parachain Block The Path of a Parachain Block (Video) Substrate \u00b6 Official Substrate Documentation","title":"Developer Resources"},{"location":"getting-started/resources/developer-resources/#cryptography","text":"blake2s used for hashing ed25519 (signing) ed25519 (curve)","title":"Cryptography"},{"location":"getting-started/resources/developer-resources/#wasm","text":"WASM Specification Wasm on the Blockchain: The Lesser Evil [blog post]","title":"WASM"},{"location":"getting-started/resources/developer-resources/#polkadot","text":"Polkadot Wiki Polkadot Consensus Wiki Polkadot Runtime Environment Specification (Section 8.2) Rust Docs: finality_grandpa paritytech/finality_grandpa The State of Crypto Interoperability Explained in Pictures","title":"Polkadot"},{"location":"getting-started/resources/developer-resources/#parachains","text":"The Parachain (Blog Post) Parachains on Polkadot Wiki Parathreads (Blog Post) Parathreads on Polkadot Wiki The Path of a Parachain Block The Path of a Parachain Block (Video)","title":"Parachains"},{"location":"getting-started/resources/developer-resources/#substrate","text":"Official Substrate Documentation","title":"Substrate"},{"location":"getting-started/resources/general-resources/","text":"Welcome \u00b6 Here you will find resources to help facilitate your learning about Polkadot . Don't worry if you are unfamiliar with these terms , the resources listed here assume no prior knowledge about them. Polkadot \u00b6 To start, it would be extremely beneficial to have an understanding of the Polkadot Network. For a high-level introduction to Polkadot, check out the lightpaper . To understand the motivation behind Polkadot's creation and what makes it unique, check out this great blog post A brief summary of everything Substrate and Polkadot . While reading, it would be helpful to note that Substrate . Additional Resources \u00b6 Docs \u00b6 Polkadot Wiki Polkadot Paper Articles \u00b6 How Polkadot tackles the biggest problems facing blockchain innovators - June 7th 2018 Block explorers \u00b6 Polkadot Explorer Polkascan - Polkadot block explorer Polkadot Telemetry Service Additional Resources \u00b6 Substrate \u00b6 Docs \u00b6 Substrate Documentation Videos \u00b6 Gavin Wood on Substrate at Event Horizon 2018 Rob Habermeier presents Parity Substrate Articles \u00b6 What is Substrate? - July 9th 2018 A brief summary of everything Substrate and Polkadot - March 18th 2019 Web3 Foundation \u00b6 Docs \u00b6 Web3 Foundation's General Grants Program Articles \u00b6 Why Wy Need Web 3.0 - September 12th 2018","title":"General Resources"},{"location":"getting-started/resources/general-resources/#welcome","text":"Here you will find resources to help facilitate your learning about Polkadot . Don't worry if you are unfamiliar with these terms , the resources listed here assume no prior knowledge about them.","title":"Welcome"},{"location":"getting-started/resources/general-resources/#polkadot","text":"To start, it would be extremely beneficial to have an understanding of the Polkadot Network. For a high-level introduction to Polkadot, check out the lightpaper . To understand the motivation behind Polkadot's creation and what makes it unique, check out this great blog post A brief summary of everything Substrate and Polkadot . While reading, it would be helpful to note that Substrate .","title":"Polkadot"},{"location":"getting-started/resources/general-resources/#additional-resources","text":"","title":"Additional Resources"},{"location":"getting-started/resources/general-resources/#docs","text":"Polkadot Wiki Polkadot Paper","title":"Docs"},{"location":"getting-started/resources/general-resources/#articles","text":"How Polkadot tackles the biggest problems facing blockchain innovators - June 7th 2018","title":"Articles"},{"location":"getting-started/resources/general-resources/#block-explorers","text":"Polkadot Explorer Polkascan - Polkadot block explorer Polkadot Telemetry Service","title":"Block explorers"},{"location":"getting-started/resources/general-resources/#additional-resources_1","text":"","title":"Additional Resources"},{"location":"getting-started/resources/general-resources/#substrate","text":"","title":"Substrate"},{"location":"getting-started/resources/general-resources/#docs_1","text":"Substrate Documentation","title":"Docs"},{"location":"getting-started/resources/general-resources/#videos","text":"Gavin Wood on Substrate at Event Horizon 2018 Rob Habermeier presents Parity Substrate","title":"Videos"},{"location":"getting-started/resources/general-resources/#articles_1","text":"What is Substrate? - July 9th 2018 A brief summary of everything Substrate and Polkadot - March 18th 2019","title":"Articles"},{"location":"getting-started/resources/general-resources/#web3-foundation","text":"","title":"Web3 Foundation"},{"location":"getting-started/resources/general-resources/#docs_2","text":"Web3 Foundation's General Grants Program","title":"Docs"},{"location":"getting-started/resources/general-resources/#articles_2","text":"Why Wy Need Web 3.0 - September 12th 2018","title":"Articles"},{"location":"usage/command-line/","text":"Commands \u00b6 Build \u00b6 This will build the Wasm Runtime and native of PINT: cargo build --release Test \u00b6 Run all tests cargo test Run all tests, including benchmarks cargo test --all-features Start the PINT chain \u00b6 ./target/release/pint --dev --instant-sealing This will seal blocks instantly. The node will never produce blocks Use the docker image: docker run -it -p 9944:9944 chainsafe/pint --tmp --dev --instant-sealing --rpc-external --ws-external --rpc-cors all --rpc-methods Unsafe If the polkadot.js UI fails to connect try adding --rpc-cors all .","title":"Command Line"},{"location":"usage/command-line/#commands","text":"","title":"Commands"},{"location":"usage/command-line/#build","text":"This will build the Wasm Runtime and native of PINT: cargo build --release","title":"Build"},{"location":"usage/command-line/#test","text":"Run all tests cargo test Run all tests, including benchmarks cargo test --all-features","title":"Test"},{"location":"usage/command-line/#start-the-pint-chain","text":"./target/release/pint --dev --instant-sealing This will seal blocks instantly. The node will never produce blocks Use the docker image: docker run -it -p 9944:9944 chainsafe/pint --tmp --dev --instant-sealing --rpc-external --ws-external --rpc-cors all --rpc-methods Unsafe If the polkadot.js UI fails to connect try adding --rpc-cors all .","title":"Start the PINT chain"},{"location":"usage/configuration/","text":"Configuration \u00b6 Polkadot JS UI \u00b6 In order to use polkadot.js UI to interact with the chain you need to specify the custom PINT is using by copying the types.json object into the input at Settings > Devoloper in the polkadot js UI menu. Chain Spec \u00b6 By default, PINT uses the dev chain spec . The GenesisConfig configures the initial chain state at genesis. Excerpt: GenesisConfig { system : SystemConfig { code : WASM_BINARY . expect ( \"WASM binary was not build, please build it!\" ). to_vec (), changes_trie_config : Default :: default (), }, // This ensures the `endowed_accounts` have funds in their accounts balances : BalancesConfig { balances : endowed_accounts . iter (). cloned (). map ( | k | ( k , 1 < < 12 )). collect () }, // This configures the comittee committee : CommitteeConfig { council_members : council_members . clone (), .. Default :: default () }, // all council members can create feeds and no feeds in genesis chainlink_feed : ChainlinkFeedConfig { feeds : Default :: default (), pallet_admin : Some ( root_key . clone ()), feed_creators : council_members }, sudo : SudoConfig { key : root_key }, parachain_info : ParachainInfoConfig { parachain_id : id }, } To run the chain with a custom chainspec we need to provide the path to your chainspec json file: NOTE: the id of your custom chain spec should contain dev in order to run it as standalone chain. ./target/release/pint --tmp --chain=<custom-chainspec.json> Read more about substrate's Chain Specification and creating private networks Build the chainspec \u00b6 ./target/release/pint build-spec \\ --disable-default-bootnode > pint-local-plain.json Build the raw chainspec file \u00b6 ./target/release/pint build-spec \\ --chain=./pint-local-plain.json \\ --raw --disable-default-bootnode > pint-local-raw.json","title":"Configuration"},{"location":"usage/configuration/#configuration","text":"","title":"Configuration"},{"location":"usage/configuration/#polkadot-js-ui","text":"In order to use polkadot.js UI to interact with the chain you need to specify the custom PINT is using by copying the types.json object into the input at Settings > Devoloper in the polkadot js UI menu.","title":"Polkadot JS UI"},{"location":"usage/configuration/#chain-spec","text":"By default, PINT uses the dev chain spec . The GenesisConfig configures the initial chain state at genesis. Excerpt: GenesisConfig { system : SystemConfig { code : WASM_BINARY . expect ( \"WASM binary was not build, please build it!\" ). to_vec (), changes_trie_config : Default :: default (), }, // This ensures the `endowed_accounts` have funds in their accounts balances : BalancesConfig { balances : endowed_accounts . iter (). cloned (). map ( | k | ( k , 1 < < 12 )). collect () }, // This configures the comittee committee : CommitteeConfig { council_members : council_members . clone (), .. Default :: default () }, // all council members can create feeds and no feeds in genesis chainlink_feed : ChainlinkFeedConfig { feeds : Default :: default (), pallet_admin : Some ( root_key . clone ()), feed_creators : council_members }, sudo : SudoConfig { key : root_key }, parachain_info : ParachainInfoConfig { parachain_id : id }, } To run the chain with a custom chainspec we need to provide the path to your chainspec json file: NOTE: the id of your custom chain spec should contain dev in order to run it as standalone chain. ./target/release/pint --tmp --chain=<custom-chainspec.json> Read more about substrate's Chain Specification and creating private networks","title":"Chain Spec"},{"location":"usage/configuration/#build-the-chainspec","text":"./target/release/pint build-spec \\ --disable-default-bootnode > pint-local-plain.json","title":"Build the chainspec"},{"location":"usage/configuration/#build-the-raw-chainspec-file","text":"./target/release/pint build-spec \\ --chain=./pint-local-plain.json \\ --raw --disable-default-bootnode > pint-local-raw.json","title":"Build the raw chainspec file"}]}